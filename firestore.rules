rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ─── Helers ───

    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user is a member of the group
    // Uses 'memberUids' for efficiency. Fallback to 'createdBy' for migration.
    function isGroupMember(groupId) {
      let group = get(/databases/$(database)/documents/groups/$(groupId)).data;
      return isAuthenticated() && (
        (group.memberUids != null && request.auth.uid in group.memberUids) || 
        group.createdBy == request.auth.uid
      );
    }

    function isMemberOfResource(resourceData) {
       return (resourceData.memberUids != null && request.auth.uid in resourceData.memberUids) || 
              resourceData.createdBy == request.auth.uid;
    }

    // ─── Rules ───

    // Groups:
    // - Create: Authenticated users. Validation: user must be in memberUids.
    // - Read/Update: Must be a member (or creator).
    // - Delete: Only Creator.
    match /groups/{groupId} {
      allow create: if isAuthenticated() && 
                    request.resource.data.createdBy == request.auth.uid &&
                    request.auth.uid in request.resource.data.memberUids;
      
      // Strict: Must be a member to read.
      allow read: if isAuthenticated() && isMemberOfResource(resource.data);
      
      allow update: if isAuthenticated() && isMemberOfResource(resource.data);
                    // Constraint: Cannot remove yourself entirely without logic? 
                    // For now, simplicity: if you are a member, you can update (e.g. edit name, add expense).
      
      allow delete: if isAuthenticated() && resource.data.createdBy == request.auth.uid;
    }

    // Expenses:
    // - Read/Write: Must be a member of the group.
    match /expenses/{expenseId} {
      allow read: if isGroupMember(resource.data.groupId);
      allow create: if isGroupMember(request.resource.data.groupId);
      allow update, delete: if isGroupMember(resource.data.groupId);
    }

    // Pool Contributions:
    match /pool_contributions/{contribId} {
      allow read, write: if isGroupMember(resource.data.groupId); // On create check request, on read check specific doc?
                                                                  // 'write' covers create/update/delete.
                                                                  // For create: request.resource.data.groupId
                                                                  // For update/delete/read: resource.data.groupId
                                                                  // Firestore uses 'resource' for read/delete, 'request.resource' for create/update.
                                                                  // We need split rules for safety.
    }
    // Split for safety:
    match /pool_contributions/{contribId} {
      allow create: if isGroupMember(request.resource.data.groupId);
      allow read, update, delete: if isGroupMember(resource.data.groupId);
    }

    // Settlements:
    match /settlements/{settlementId} {
      allow create: if isGroupMember(request.resource.data.groupId);
      allow read, update, delete: if isGroupMember(resource.data.groupId);
    }

    // Recurring Expenses:
    match /recurring_expenses/{recurringId} {
      allow create: if isGroupMember(request.resource.data.groupId);
      allow read, update, delete: if isGroupMember(resource.data.groupId);
    }

    // Notifications: 
    // - Write: Allow if for self, OR if targeting a group member (anti-spam check)
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      allow create: if isAuthenticated() && (
        // Case 1: Self notification
        request.resource.data.userId == request.auth.uid || 
        // Case 2: Group notification (must be member of group)
        (request.resource.data.groupId != null && isGroupMember(request.resource.data.groupId))
      );

      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Users: Private data
    match /users/{userId}/fcmTokens/{tokenId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // Global User Profiles (Public Read, Private Write)
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && request.auth.uid == userId;
    }
  }
}
